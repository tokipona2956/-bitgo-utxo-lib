var Buffer = require('safe-buffer').Buffer;
var createHmac = require('create-hmac');
var typeforce = require('typeforce');
var types = require('./types');
var BigInteger = require('bigi');
var ECSignature = require('./ecsignature');
var ZERO = Buffer.alloc(1, 0);
var ONE = Buffer.alloc(1, 1);
var ecurve = require('ecurve');
var secp256k1 = ecurve.getCurveByName('secp256k1');
// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK(hash, x, checkSig) {
    typeforce(types.tuple(types.Hash256bit, types.Buffer256bit, types.Function), arguments);
    // Step A, ignored as hash already provided
    // Step B
    // Step C
    var k = Buffer.alloc(32, 0);
    var v = Buffer.alloc(32, 1);
    // Step D
    k = createHmac('sha256', k)
        .update(v)
        .update(ZERO)
        .update(x)
        .update(hash)
        .digest();
    // Step E
    v = createHmac('sha256', k).update(v).digest();
    // Step F
    k = createHmac('sha256', k)
        .update(v)
        .update(ONE)
        .update(x)
        .update(hash)
        .digest();
    // Step G
    v = createHmac('sha256', k).update(v).digest();
    // Step H1/H2a, ignored as tlen === qlen (256 bit)
    // Step H2b
    v = createHmac('sha256', k).update(v).digest();
    var T = BigInteger.fromBuffer(v);
    // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA
    while (T.signum() <= 0 || T.compareTo(secp256k1.n) >= 0 || !checkSig(T)) {
        k = createHmac('sha256', k)
            .update(v)
            .update(ZERO)
            .digest();
        v = createHmac('sha256', k).update(v).digest();
        // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
        // Step H2b again
        v = createHmac('sha256', k).update(v).digest();
        T = BigInteger.fromBuffer(v);
    }
    return T;
}
var N_OVER_TWO = secp256k1.n.shiftRight(1);
function sign(hash, d) {
    typeforce(types.tuple(types.Hash256bit, types.BigInt), arguments);
    var x = d.toBuffer(32);
    var e = BigInteger.fromBuffer(hash);
    var n = secp256k1.n;
    var G = secp256k1.G;
    var r, s;
    deterministicGenerateK(hash, x, function (k) {
        var Q = G.multiply(k);
        if (secp256k1.isInfinity(Q))
            return false;
        r = Q.affineX.mod(n);
        if (r.signum() === 0)
            return false;
        s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
        if (s.signum() === 0)
            return false;
        return true;
    });
    // enforce low S values, see bip62: 'low s values in signatures'
    if (s.compareTo(N_OVER_TWO) > 0) {
        s = n.subtract(s);
    }
    return new ECSignature(r, s);
}
function verify(hash, signature, Q) {
    typeforce(types.tuple(types.Hash256bit, types.ECSignature, types.ECPoint), arguments);
    var n = secp256k1.n;
    var G = secp256k1.G;
    var r = signature.r;
    var s = signature.s;
    // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]
    if (r.signum() <= 0 || r.compareTo(n) >= 0)
        return false;
    if (s.signum() <= 0 || s.compareTo(n) >= 0)
        return false;
    // 1.4.2 H = Hash(M), already done by the user
    // 1.4.3 e = H
    var e = BigInteger.fromBuffer(hash);
    // Compute s^-1
    var sInv = s.modInverse(n);
    // 1.4.4 Compute u1 = es^−1 mod n
    //               u2 = rs^−1 mod n
    var u1 = e.multiply(sInv).mod(n);
    var u2 = r.multiply(sInv).mod(n);
    // 1.4.5 Compute R = (xR, yR)
    //               R = u1G + u2Q
    var R = G.multiplyTwo(u1, Q, u2);
    // 1.4.5 (cont.) Enforce R is not at infinity
    if (secp256k1.isInfinity(R))
        return false;
    // 1.4.6 Convert the field element R.x to an integer
    var xR = R.affineX;
    // 1.4.7 Set v = xR mod n
    var v = xR.mod(n);
    // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
    return v.equals(r);
}
module.exports = {
    deterministicGenerateK: deterministicGenerateK,
    sign: sign,
    verify: verify,
    // TODO: remove
    __curve: secp256k1
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNkc2EuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZWNkc2EuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLE1BQU0sQ0FBQTtBQUMxQyxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUE7QUFDdkMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFBO0FBQ3BDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQTtBQUU5QixJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUE7QUFDaEMsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFBO0FBRTFDLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO0FBQzdCLElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO0FBRTVCLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUM5QixJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFBO0FBRWxELGtEQUFrRDtBQUNsRCxTQUFTLHNCQUFzQixDQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsUUFBUTtJQUNoRCxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FDbkIsS0FBSyxDQUFDLFVBQVUsRUFDaEIsS0FBSyxDQUFDLFlBQVksRUFDbEIsS0FBSyxDQUFDLFFBQVEsQ0FDZixFQUFFLFNBQVMsQ0FBQyxDQUFBO0lBRWIsMkNBQTJDO0lBQzNDLFNBQVM7SUFDVCxTQUFTO0lBQ1QsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUE7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TyxDQUFBO0lBRWxCLHlCQUF5QjtJQUN6QixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBRWpCLGtFQUFrRTtJQUNsRSxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDcEIsQ0FBQztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDZixzQkFBc0IsRUFBRSxzQkFBc0I7SUFDOUMsSUFBSSxFQUFFLElBQUk7SUFDVixNQUFNLEVBQUUsTUFBTTtJQUVkLGVBQWU7SUFDZixPQUFPLEVBQUUsU0FBUztDQUNuQixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY3JlYXRlSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJylcbnZhciB0eXBlZm9yY2UgPSByZXF1aXJlKCd0eXBlZm9yY2UnKVxudmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpXG5cbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpXG52YXIgRUNTaWduYXR1cmUgPSByZXF1aXJlKCcuL2Vjc2lnbmF0dXJlJylcblxudmFyIFpFUk8gPSBCdWZmZXIuYWxsb2MoMSwgMClcbnZhciBPTkUgPSBCdWZmZXIuYWxsb2MoMSwgMSlcblxudmFyIGVjdXJ2ZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpXG52YXIgc2VjcDI1NmsxID0gZWN1cnZlLmdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKVxuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjk3OSNzZWN0aW9uLTMuMlxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSyAoaGFzaCwgeCwgY2hlY2tTaWcpIHtcbiAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKFxuICAgIHR5cGVzLkhhc2gyNTZiaXQsXG4gICAgdHlwZXMuQnVmZmVyMjU2Yml0LFxuICAgIHR5cGVzLkZ1bmN0aW9uXG4gICksIGFyZ3VtZW50cylcblxuICAvLyBTdGVwIEEsIGlnbm9yZWQgYXMgaGFzaCBhbHJlYWR5IHByb3ZpZGVkXG4gIC8vIFN0ZXAgQlxuICAvLyBTdGVwIENcbiAgdmFyIGsgPSBCdWZmZXIuYWxsb2MoMzIsIDApXG4gIHZhciB2ID0gQnVmZmVyLmFsbG9jKDMyLCAxKVxuXG4gIC8vIFN0ZXAgRFxuICBrID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaylcbiAgICAudXBkYXRlKHYpXG4gICAgLnVwZGF0ZShaRVJPKVxuICAgIC51cGRhdGUoeClcbiAgICAudXBkYXRlKGhhc2gpXG4gICAgLmRpZ2VzdCgpXG5cbiAgLy8gU3RlcCBFXG4gIHYgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKS51cGRhdGUodikuZGlnZXN0KClcblxuICAvLyBTdGVwIEZcbiAgayA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGspXG4gICAgLnVwZGF0ZSh2KVxuICAgIC51cGRhdGUoT05FKVxuICAgIC51cGRhdGUoeClcbiAgICAudXBkYXRlKGhhc2gpXG4gICAgLmRpZ2VzdCgpXG5cbiAgLy8gU3RlcCBHXG4gIHYgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKS51cGRhdGUodikuZGlnZXN0KClcblxuICAvLyBTdGVwIEgxL0gyYSwgaWdub3JlZCBhcyB0bGVuID09PSBxbGVuICgyNTYgYml0KVxuICAvLyBTdGVwIEgyYlxuICB2ID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG5cbiAgdmFyIFQgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIodilcblxuICAvLyBTdGVwIEgzLCByZXBlYXQgdW50aWwgVCBpcyB3aXRoaW4gdGhlIGludGVydmFsIFsxLCBuIC0gMV0gYW5kIGlzIHN1aXRhYmxlIGZvciBFQ0RTQVxuICB3aGlsZSAoVC5zaWdudW0oKSA8PSAwIHx8IFQuY29tcGFyZVRvKHNlY3AyNTZrMS5uKSA+PSAwIHx8ICFjaGVja1NpZyhUKSkge1xuICAgIGsgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKVxuICAgICAgLnVwZGF0ZSh2KVxuICAgICAgLnVwZGF0ZShaRVJPKVxuICAgICAgLmRpZ2VzdCgpXG5cbiAgICB2ID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG5cbiAgICAvLyBTdGVwIEgxL0gyYSwgYWdhaW4sIGlnbm9yZWQgYXMgdGxlbiA9PT0gcWxlbiAoMjU2IGJpdClcbiAgICAvLyBTdGVwIEgyYiBhZ2FpblxuICAgIHYgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKS51cGRhdGUodikuZGlnZXN0KClcbiAgICBUID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKHYpXG4gIH1cblxuICByZXR1cm4gVFxufVxuXG52YXIgTl9PVkVSX1RXTyA9IHNlY3AyNTZrMS5uLnNoaWZ0UmlnaHQoMSlcblxuZnVuY3Rpb24gc2lnbiAoaGFzaCwgZCkge1xuICB0eXBlZm9yY2UodHlwZXMudHVwbGUodHlwZXMuSGFzaDI1NmJpdCwgdHlwZXMuQmlnSW50KSwgYXJndW1lbnRzKVxuXG4gIHZhciB4ID0gZC50b0J1ZmZlcigzMilcbiAgdmFyIGUgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoaGFzaClcbiAgdmFyIG4gPSBzZWNwMjU2azEublxuICB2YXIgRyA9IHNlY3AyNTZrMS5HXG5cbiAgdmFyIHIsIHNcbiAgZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSyhoYXNoLCB4LCBmdW5jdGlvbiAoaykge1xuICAgIHZhciBRID0gRy5tdWx0aXBseShrKVxuXG4gICAgaWYgKHNlY3AyNTZrMS5pc0luZmluaXR5KFEpKSByZXR1cm4gZmFsc2VcblxuICAgIHIgPSBRLmFmZmluZVgubW9kKG4pXG4gICAgaWYgKHIuc2lnbnVtKCkgPT09IDApIHJldHVybiBmYWxzZVxuXG4gICAgcyA9IGsubW9kSW52ZXJzZShuKS5tdWx0aXBseShlLmFkZChkLm11bHRpcGx5KHIpKSkubW9kKG4pXG4gICAgaWYgKHMuc2lnbnVtKCkgPT09IDApIHJldHVybiBmYWxzZVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSlcblxuICAvLyBlbmZvcmNlIGxvdyBTIHZhbHVlcywgc2VlIGJpcDYyOiAnbG93IHMgdmFsdWVzIGluIHNpZ25hdHVyZXMnXG4gIGlmIChzLmNvbXBhcmVUbyhOX09WRVJfVFdPKSA+IDApIHtcbiAgICBzID0gbi5zdWJ0cmFjdChzKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBFQ1NpZ25hdHVyZShyLCBzKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnkgKGhhc2gsIHNpZ25hdHVyZSwgUSkge1xuICB0eXBlZm9yY2UodHlwZXMudHVwbGUoXG4gICAgdHlwZXMuSGFzaDI1NmJpdCxcbiAgICB0eXBlcy5FQ1NpZ25hdHVyZSxcbiAgICB0eXBlcy5FQ1BvaW50XG4gICksIGFyZ3VtZW50cylcblxuICB2YXIgbiA9IHNlY3AyNTZrMS5uXG4gIHZhciBHID0gc2VjcDI1NmsxLkdcblxuICB2YXIgciA9IHNpZ25hdHVyZS5yXG4gIHZhciBzID0gc2lnbmF0dXJlLnNcblxuICAvLyAxLjQuMSBFbmZvcmNlIHIgYW5kIHMgYXJlIGJvdGggaW50ZWdlcnMgaW4gdGhlIGludGVydmFsIFsxLCBuIOKIkiAxXVxuICBpZiAoci5zaWdudW0oKSA8PSAwIHx8IHIuY29tcGFyZVRvKG4pID49IDApIHJldHVybiBmYWxzZVxuICBpZiAocy5zaWdudW0oKSA8PSAwIHx8IHMuY29tcGFyZVRvKG4pID49IDApIHJldHVybiBmYWxzZVxuXG4gIC8vIDEuNC4yIEggPSBIYXNoKE0pLCBhbHJlYWR5IGRvbmUgYnkgdGhlIHVzZXJcbiAgLy8gMS40LjMgZSA9IEhcbiAgdmFyIGUgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoaGFzaClcblxuICAvLyBDb21wdXRlIHNeLTFcbiAgdmFyIHNJbnYgPSBzLm1vZEludmVyc2UobilcblxuICAvLyAxLjQuNCBDb21wdXRlIHUxID0gZXNe4oiSMSBtb2QgblxuICAvLyAgICAgICAgICAgICAgIHUyID0gcnNe4oiSMSBtb2QgblxuICB2YXIgdTEgPSBlLm11bHRpcGx5KHNJbnYpLm1vZChuKVxuICB2YXIgdTIgPSByLm11bHRpcGx5KHNJbnYpLm1vZChuKVxuXG4gIC8vIDEuNC41IENvbXB1dGUgUiA9ICh4UiwgeVIpXG4gIC8vICAgICAgICAgICAgICAgUiA9IHUxRyArIHUyUVxuICB2YXIgUiA9IEcubXVsdGlwbHlUd28odTEsIFEsIHUyKVxuXG4gIC8vIDEuNC41IChjb250LikgRW5mb3JjZSBSIGlzIG5vdCBhdCBpbmZpbml0eVxuICBpZiAoc2VjcDI1NmsxLmlzSW5maW5pdHkoUikpIHJldHVybiBmYWxzZVxuXG4gIC8vIDEuNC42IENvbnZlcnQgdGhlIGZpZWxkIGVsZW1lbnQgUi54IHRvIGFuIGludGVnZXJcbiAgdmFyIHhSID0gUi5hZmZpbmVYXG5cbiAgLy8gMS40LjcgU2V0IHYgPSB4UiBtb2QgblxuICB2YXIgdiA9IHhSLm1vZChuKVxuXG4gIC8vIDEuNC44IElmIHYgPSByLCBvdXRwdXQgXCJ2YWxpZFwiLCBhbmQgaWYgdiAhPSByLCBvdXRwdXQgXCJpbnZhbGlkXCJcbiAgcmV0dXJuIHYuZXF1YWxzKHIpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXRlcm1pbmlzdGljR2VuZXJhdGVLOiBkZXRlcm1pbmlzdGljR2VuZXJhdGVLLFxuICBzaWduOiBzaWduLFxuICB2ZXJpZnk6IHZlcmlmeSxcblxuICAvLyBUT0RPOiByZW1vdmVcbiAgX19jdXJ2ZTogc2VjcDI1NmsxXG59XG4iXX0=