var Buffer = require('safe-buffer').Buffer;
var base58check = require('bs58check');
var bcrypto = require('./crypto');
var createHmac = require('create-hmac');
var typeforce = require('typeforce');
var types = require('./types');
var NETWORKS = require('./networks');
var BigInteger = require('bigi');
var ECPair = require('./ecpair');
var ecurve = require('ecurve');
var curve = ecurve.getCurveByName('secp256k1');
var fastcurve = require('./fastcurve');
function HDNode(keyPair, chainCode) {
    typeforce(types.tuple('ECPair', types.Buffer256bit), arguments);
    if (!keyPair.compressed)
        throw new TypeError('BIP32 only allows compressed keyPairs');
    this.keyPair = keyPair;
    this.chainCode = chainCode;
    this.depth = 0;
    this.index = 0;
    this.parentFingerprint = 0x00000000;
    this.derivationCache = {};
}
HDNode.HIGHEST_BIT = 0x80000000;
HDNode.LENGTH = 78;
HDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');
HDNode.fromSeedBuffer = function (seed, network) {
    typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments);
    if (seed.length < 16)
        throw new TypeError('Seed should be at least 128 bits');
    if (seed.length > 64)
        throw new TypeError('Seed should be at most 512 bits');
    var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest();
    var IL = I.slice(0, 32);
    var IR = I.slice(32);
    // In case IL is 0 or >= n, the master key is invalid
    // This is handled by the ECPair constructor
    var pIL = BigInteger.fromBuffer(IL);
    var keyPair = new ECPair(pIL, null, {
        network: network
    });
    return new HDNode(keyPair, IR);
};
HDNode.fromSeedHex = function (hex, network) {
    return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network);
};
HDNode.fromBase58 = function (string, networks) {
    var buffer = base58check.decode(string);
    if (buffer.length !== 78)
        throw new Error('Invalid buffer length');
    // 4 bytes: version bytes
    var version = buffer.readUInt32BE(0);
    var network;
    // list of networks?
    if (Array.isArray(networks)) {
        // FIXME(BG-16845):
        // This is only useful when you know the coin but you are not sure if it is mainnet or testnet.
        // All mainnets have xpub/xprv and all testnets have tpub/tprv as version.
        network = networks.filter(function (x) {
            return version === x.bip32.private ||
                version === x.bip32.public;
        }).pop();
        if (!network)
            throw new Error('Unknown network version');
        // otherwise, assume a network object (or default to bitcoin)
    }
    else {
        network = networks || NETWORKS.bitcoin;
    }
    if (version !== network.bip32.private &&
        version !== network.bip32.public)
        throw new Error('Invalid network version');
    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
    var depth = buffer[4];
    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
    var parentFingerprint = buffer.readUInt32BE(5);
    if (depth === 0) {
        if (parentFingerprint !== 0x00000000)
            throw new Error('Invalid parent fingerprint');
    }
    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
    // This is encoded in MSB order. (0x00000000 if master key)
    var index = buffer.readUInt32BE(9);
    if (depth === 0 && index !== 0)
        throw new Error('Invalid index');
    // 32 bytes: the chain code
    var chainCode = buffer.slice(13, 45);
    var keyPair;
    // 33 bytes: private key data (0x00 + k)
    if (version === network.bip32.private) {
        if (buffer.readUInt8(45) !== 0x00)
            throw new Error('Invalid private key');
        var d = BigInteger.fromBuffer(buffer.slice(46, 78));
        keyPair = new ECPair(d, null, { network: network });
        // 33 bytes: public key data (0x02 + X or 0x03 + X)
    }
    else {
        var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78));
        // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw
        // Verify that the X coordinate in the public point corresponds to a point on the curve.
        // If not, the extended public key is invalid.
        curve.validate(Q);
        keyPair = new ECPair(null, Q, { network: network });
    }
    var hd = new HDNode(keyPair, chainCode);
    hd.depth = depth;
    hd.index = index;
    hd.parentFingerprint = parentFingerprint;
    return hd;
};
HDNode.prototype.getAddress = function () {
    return this.keyPair.getAddress();
};
HDNode.prototype.getIdentifier = function () {
    return bcrypto.hash160(this.keyPair.getPublicKeyBuffer());
};
HDNode.prototype.getFingerprint = function () {
    return this.getIdentifier().slice(0, 4);
};
HDNode.prototype.getNetwork = function () {
    return this.keyPair.getNetwork();
};
HDNode.prototype.getPublicKeyBuffer = function () {
    return this.keyPair.getPublicKeyBuffer();
};
HDNode.prototype.neutered = function () {
    var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {
        network: this.keyPair.network
    });
    var neutered = new HDNode(neuteredKeyPair, this.chainCode);
    neutered.depth = this.depth;
    neutered.index = this.index;
    neutered.parentFingerprint = this.parentFingerprint;
    return neutered;
};
HDNode.prototype.sign = function (hash) {
    return this.keyPair.sign(hash);
};
HDNode.prototype.verify = function (hash, signature) {
    return this.keyPair.verify(hash, signature);
};
HDNode.prototype.toBase58 = function (__isPrivate) {
    if (__isPrivate !== undefined)
        throw new TypeError('Unsupported argument in 2.0.0');
    // Version
    var network = this.keyPair.network;
    var version = (!this.isNeutered()) ? network.bip32.private : network.bip32.public;
    var buffer = Buffer.allocUnsafe(78);
    // 4 bytes: version bytes
    buffer.writeUInt32BE(version, 0);
    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
    buffer.writeUInt8(this.depth, 4);
    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
    buffer.writeUInt32BE(this.parentFingerprint, 5);
    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
    // This is encoded in big endian. (0x00000000 if master key)
    buffer.writeUInt32BE(this.index, 9);
    // 32 bytes: the chain code
    this.chainCode.copy(buffer, 13);
    // 33 bytes: the public key or private key data
    if (!this.isNeutered()) {
        // 0x00 + k for private keys
        buffer.writeUInt8(0, 45);
        this.keyPair.d.toBuffer(32).copy(buffer, 46);
        // 33 bytes: the public key
    }
    else {
        // X9.62 encoding for public keys
        this.keyPair.getPublicKeyBuffer().copy(buffer, 45);
    }
    return base58check.encode(buffer);
};
// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
HDNode.prototype.derive = function (index) {
    typeforce(types.UInt32, index);
    var isHardened = index >= HDNode.HIGHEST_BIT;
    var data = Buffer.allocUnsafe(37);
    // Hardened child
    if (isHardened) {
        if (this.isNeutered())
            throw new TypeError('Could not derive hardened child key');
        // data = 0x00 || ser256(kpar) || ser32(index)
        data[0] = 0x00;
        this.keyPair.d.toBuffer(32).copy(data, 1);
        data.writeUInt32BE(index, 33);
        // Normal child
    }
    else {
        // data = serP(point(kpar)) || ser32(index)
        //      = serP(Kpar) || ser32(index)
        this.keyPair.getPublicKeyBuffer().copy(data, 0);
        data.writeUInt32BE(index, 33);
    }
    var I = createHmac('sha512', this.chainCode).update(data).digest();
    var IL = I.slice(0, 32);
    var IR = I.slice(32);
    var pIL = BigInteger.fromBuffer(IL);
    // In case parse256(IL) >= n, proceed with the next value for i
    if (pIL.compareTo(curve.n) >= 0) {
        return this.derive(index + 1);
    }
    // Private parent key -> private child key
    var derivedKeyPair;
    if (!this.isNeutered()) {
        // ki = parse256(IL) + kpar (mod n)
        var ki = pIL.add(this.keyPair.d).mod(curve.n);
        // In case ki == 0, proceed with the next value for i
        if (ki.signum() === 0) {
            return this.derive(index + 1);
        }
        derivedKeyPair = new ECPair(ki, null, {
            network: this.keyPair.network
        });
        // Public parent key -> public child key
    }
    else {
        // Ki = point(parse256(IL)) + Kpar
        //    = G*IL + Kpar
        var point = fastcurve.publicKeyCreate(IL, false);
        var Ki = point !== undefined
            ? ecurve.Point.decodeFrom(curve, point).add(this.keyPair.Q)
            : curve.G.multiply(pIL).add(this.keyPair.Q);
        // In case Ki is the point at infinity, proceed with the next value for i
        if (curve.isInfinity(Ki)) {
            return this.derive(index + 1);
        }
        derivedKeyPair = new ECPair(null, Ki, {
            network: this.keyPair.network
        });
    }
    var hd = new HDNode(derivedKeyPair, IR);
    hd.depth = this.depth + 1;
    hd.index = index;
    hd.parentFingerprint = this.getFingerprint().readUInt32BE(0);
    return hd;
};
HDNode.prototype.deriveHardened = function (index) {
    typeforce(types.UInt31, index);
    // Only derives hardened private keys by default
    return this.derive(index + HDNode.HIGHEST_BIT);
};
// Private === not neutered
// Public === neutered
HDNode.prototype.isNeutered = function () {
    return !(this.keyPair.d);
};
HDNode.prototype.derivePath = function (path, cache) {
    typeforce(types.BIP32Path, path);
    typeforce(types.maybe(types.Object), cache);
    cache = cache || this.derivationCache;
    var splitPath = path.split('/');
    if (splitPath[0] === 'm') {
        if (this.parentFingerprint) {
            throw new Error('Not a master node');
        }
        splitPath = splitPath.slice(1);
    }
    return splitPath.reduce(function (prevHd, indexStr) {
        var index;
        var cacheObject = cache[indexStr] || {};
        if (cacheObject.node) {
            cache = cacheObject.next;
            return cacheObject.node;
        }
        if (indexStr.slice(-1) === "'") {
            index = parseInt(indexStr.slice(0, -1), 10);
            cacheObject.node = prevHd.deriveHardened(index);
        }
        else {
            index = parseInt(indexStr, 10);
            cacheObject.node = prevHd.derive(index);
        }
        cache[indexStr] = cacheObject;
        cacheObject.next = {};
        cache = cacheObject.next;
        return cacheObject.node;
    }, this);
};
/**
 * Create a new ECPair object from this HDNode's ECPair.
 *
 * Uses secp256k1 if available for accelerated computation of the cloned public key.
 * @return {ECPair}
 */
HDNode.prototype.cloneKeypair = function () {
    var k = this.keyPair;
    var result = new ECPair(k.d, k.d ? null : k.Q, {
        network: k.network,
        compressed: k.compressed
    });
    // Creating Q from d takes ~25ms, so if it's not created, use native bindings to pre-compute
    // if Q is not set here, it will be lazily computed via the slow path
    if (!result.__Q) {
        var point = fastcurve.publicKeyCreate(k.d.toBuffer(32), false);
        if (point !== undefined) {
            result.__Q = ecurve.Point.decodeFrom(curve, point);
        }
    }
    return result;
};
module.exports = HDNode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGRub2RlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2hkbm9kZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsTUFBTSxDQUFBO0FBQzFDLElBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQTtBQUN0QyxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUE7QUFDakMsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFBO0FBQ3ZDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQTtBQUNwQyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUE7QUFDOUIsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFBO0FBRXBDLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQTtBQUNoQyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUE7QUFFaEMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBQzlCLElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUE7QUFFOUMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFBO0FBRXRDLFNBQVMsTUFBTSxDQUFFLE9BQU8sRUFBRSxTQUFTO0lBQ2pDLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUE7SUFFL0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVO1FBQUUsTUFBTSxJQUFJLFNBQVMsQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFBO0lBRXJGLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FB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QUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQzdDLE9BQU8sRUFBRSxDQUFDLENBQUMsT0FBTztRQUNsQixVQUFVLEVBQUUsQ0FBQyxDQUFDLFVBQVU7S0FDekIsQ0FBQyxDQUFBO0lBQ0YsNEZBQTRGO0lBQzVGLHFFQUFxRTtJQUNyRSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRTtRQUNmLElBQUksS0FBSyxHQUFHLFNBQVMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7UUFDOUQsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLE1BQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFBO1NBQ25EO0tBQ0Y7SUFDRCxPQUFPLE1BQU0sQ0FBQTtBQUNmLENBQUMsQ0FBQTtBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgYmFzZTU4Y2hlY2sgPSByZXF1aXJlKCdiczU4Y2hlY2snKVxudmFyIGJjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpXG52YXIgY3JlYXRlSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJylcbnZhciB0eXBlZm9yY2UgPSByZXF1aXJlKCd0eXBlZm9yY2UnKVxudmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpXG52YXIgTkVUV09SS1MgPSByZXF1aXJlKCcuL25ldHdvcmtzJylcblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJylcbnZhciBFQ1BhaXIgPSByZXF1aXJlKCcuL2VjcGFpcicpXG5cbnZhciBlY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKVxudmFyIGN1cnZlID0gZWN1cnZlLmdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKVxuXG52YXIgZmFzdGN1cnZlID0gcmVxdWlyZSgnLi9mYXN0Y3VydmUnKVxuXG5mdW5jdGlvbiBIRE5vZGUgKGtleVBhaXIsIGNoYWluQ29kZSkge1xuICB0eXBlZm9yY2UodHlwZXMudHVwbGUoJ0VDUGFpcicsIHR5cGVzLkJ1ZmZlcjI1NmJpdCksIGFyZ3VtZW50cylcblxuICBpZiAoIWtleVBhaXIuY29tcHJlc3NlZCkgdGhyb3cgbmV3IFR5cGVFcnJvcignQklQMzIgb25seSBhbGxvd3MgY29tcHJlc3NlZCBrZXlQYWlycycpXG5cbiAgdGhpcy5rZXlQYWlyID0ga2V5UGFpclxuICB0aGlzLmNoYWluQ29kZSA9IGNoYWluQ29kZVxuICB0aGlzLmRlcHRoID0gMFxuICB0aGlzLmluZGV4ID0gMFxuICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMHgwMDAwMDAwMFxuICB0aGlzLmRlcml2YXRpb25DYWNoZSA9IHt9XG59XG5cbkhETm9kZS5ISUdIRVNUX0JJVCA9IDB4ODAwMDAwMDBcbkhETm9kZS5MRU5HVEggPSA3OFxuSEROb2RlLk1BU1RFUl9TRUNSRVQgPSBCdWZmZXIuZnJvbSgnQml0Y29pbiBzZWVkJywgJ3V0ZjgnKVxuXG5IRE5vZGUuZnJvbVNlZWRCdWZmZXIgPSBmdW5jdGlvbiAoc2VlZCwgbmV0d29yaykge1xuICB0eXBlZm9yY2UodHlwZXMudHVwbGUodHlwZXMuQnVmZmVyLCB0eXBlcy5tYXliZSh0eXBlcy5OZXR3b3JrKSksIGFyZ3VtZW50cylcblxuICBpZiAoc2VlZC5sZW5ndGggPCAxNikgdGhyb3cgbmV3IFR5cGVFcnJvcignU2VlZCBzaG91bGQgYmUgYXQgbGVhc3QgMTI4IGJpdHMnKVxuICBpZiAoc2VlZC5sZW5ndGggPiA2NCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU2VlZCBzaG91bGQgYmUgYXQgbW9zdCA1MTIgYml0cycpXG5cbiAgdmFyIEkgPSBjcmVhdGVIbWFjKCdzaGE1MTInLCBIRE5vZGUuTUFTVEVSX1NFQ1JFVCkudXBkYXRlKHNlZWQpLmRpZ2VzdCgpXG4gIHZhciBJTCA9IEkuc2xpY2UoMCwgMzIpXG4gIHZhciBJUiA9IEkuc2xpY2UoMzIpXG5cbiAgLy8gSW4gY2FzZSBJTCBpcyAwIG9yID49IG4sIHRoZSBtYXN0ZXIga2V5IGlzIGludmFsaWRcbiAgLy8gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBFQ1BhaXIgY29uc3RydWN0b3JcbiAgdmFyIHBJTCA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihJTClcbiAgdmFyIGtleVBhaXIgPSBuZXcgRUNQYWlyKHBJTCwgbnVsbCwge1xuICAgIG5ldHdvcms6IG5ldHdvcmtcbiAgfSlcblxuICByZXR1cm4gbmV3IEhETm9kZShrZXlQYWlyLCBJUilcbn1cblxuSEROb2RlLmZyb21TZWVkSGV4ID0gZnVuY3Rpb24gKGhleCwgbmV0d29yaykge1xuICByZXR1cm4gSEROb2RlLmZyb21TZWVkQnVmZmVyKEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpLCBuZXR3b3JrKVxufVxuXG5IRE5vZGUuZnJvbUJhc2U1OCA9IGZ1bmN0aW9uIChzdHJpbmcsIG5ldHdvcmtzKSB7XG4gIHZhciBidWZmZXIgPSBiYXNlNThjaGVjay5kZWNvZGUoc3RyaW5nKVxuICBpZiAoYnVmZmVyLmxlbmd0aCAhPT0gNzgpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBidWZmZXIgbGVuZ3RoJylcblxuICAvLyA0IGJ5dGVzOiB2ZXJzaW9uIGJ5dGVzXG4gIHZhciB2ZXJzaW9uID0gYnVmZmVyLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgbmV0d29ya1xuXG4gIC8vIGxpc3Qgb2YgbmV0d29ya3M/XG4gIGlmIChBcnJheS5pc0FycmF5KG5ldHdvcmtzKSkge1xuICAgIC8vIEZJWE1FKEJHLTE2ODQ1KTpcbiAgICAvLyBUaGlzIGlzIG9ubHkgdXNlZnVsIHdoZW4geW91IGtub3cgdGhlIGNvaW4gYnV0IHlvdSBhcmUgbm90IHN1cmUgaWYgaXQgaXMgbWFpbm5ldCBvciB0ZXN0bmV0LlxuICAgIC8vIEFsbCBtYWlubmV0cyBoYXZlIHhwdWIveHBydiBhbmQgYWxsIHRlc3RuZXRzIGhhdmUgdHB1Yi90cHJ2IGFzIHZlcnNpb24uXG4gICAgbmV0d29yayA9IG5ldHdvcmtzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHZlcnNpb24gPT09IHguYmlwMzIucHJpdmF0ZSB8fFxuICAgICAgICAgICAgIHZlcnNpb24gPT09IHguYmlwMzIucHVibGljXG4gICAgfSkucG9wKClcblxuICAgIGlmICghbmV0d29yaykgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5ldHdvcmsgdmVyc2lvbicpXG5cbiAgLy8gb3RoZXJ3aXNlLCBhc3N1bWUgYSBuZXR3b3JrIG9iamVjdCAob3IgZGVmYXVsdCB0byBiaXRjb2luKVxuICB9IGVsc2Uge1xuICAgIG5ldHdvcmsgPSBuZXR3b3JrcyB8fCBORVRXT1JLUy5iaXRjb2luXG4gIH1cblxuICBpZiAodmVyc2lvbiAhPT0gbmV0d29yay5iaXAzMi5wcml2YXRlICYmXG4gICAgdmVyc2lvbiAhPT0gbmV0d29yay5iaXAzMi5wdWJsaWMpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuZXR3b3JrIHZlcnNpb24nKVxuXG4gIC8vIDEgYnl0ZTogZGVwdGg6IDB4MDAgZm9yIG1hc3RlciBub2RlcywgMHgwMSBmb3IgbGV2ZWwtMSBkZXNjZW5kYW50cywgLi4uXG4gIHZhciBkZXB0aCA9IGJ1ZmZlcls0XVxuXG4gIC8vIDQgYnl0ZXM6IHRoZSBmaW5nZXJwcmludCBvZiB0aGUgcGFyZW50J3Mga2V5ICgweDAwMDAwMDAwIGlmIG1hc3RlciBrZXkpXG4gIHZhciBwYXJlbnRGaW5nZXJwcmludCA9IGJ1ZmZlci5yZWFkVUludDMyQkUoNSlcbiAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgaWYgKHBhcmVudEZpbmdlcnByaW50ICE9PSAweDAwMDAwMDAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyZW50IGZpbmdlcnByaW50JylcbiAgfVxuXG4gIC8vIDQgYnl0ZXM6IGNoaWxkIG51bWJlci4gVGhpcyBpcyB0aGUgbnVtYmVyIGkgaW4geGkgPSB4cGFyL2ksIHdpdGggeGkgdGhlIGtleSBiZWluZyBzZXJpYWxpemVkLlxuICAvLyBUaGlzIGlzIGVuY29kZWQgaW4gTVNCIG9yZGVyLiAoMHgwMDAwMDAwMCBpZiBtYXN0ZXIga2V5KVxuICB2YXIgaW5kZXggPSBidWZmZXIucmVhZFVJbnQzMkJFKDkpXG4gIGlmIChkZXB0aCA9PT0gMCAmJiBpbmRleCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4JylcblxuICAvLyAzMiBieXRlczogdGhlIGNoYWluIGNvZGVcbiAgdmFyIGNoYWluQ29kZSA9IGJ1ZmZlci5zbGljZSgxMywgNDUpXG4gIHZhciBrZXlQYWlyXG5cbiAgLy8gMzMgYnl0ZXM6IHByaXZhdGUga2V5IGRhdGEgKDB4MDAgKyBrKVxuICBpZiAodmVyc2lvbiA9PT0gbmV0d29yay5iaXAzMi5wcml2YXRlKSB7XG4gICAgaWYgKGJ1ZmZlci5yZWFkVUludDgoNDUpICE9PSAweDAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKVxuXG4gICAgdmFyIGQgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmZmVyLnNsaWNlKDQ2LCA3OCkpXG4gICAga2V5UGFpciA9IG5ldyBFQ1BhaXIoZCwgbnVsbCwgeyBuZXR3b3JrOiBuZXR3b3JrIH0pXG5cbiAgLy8gMzMgYnl0ZXM6IHB1YmxpYyBrZXkgZGF0YSAoMHgwMiArIFggb3IgMHgwMyArIFgpXG4gIH0gZWxzZSB7XG4gICAgdmFyIFEgPSBlY3VydmUuUG9pbnQuZGVjb2RlRnJvbShjdXJ2ZSwgYnVmZmVyLnNsaWNlKDQ1LCA3OCkpXG4gICAgLy8gUS5jb21wcmVzc2VkIGlzIGFzc3VtZWQsIGlmIHNvbWVob3cgdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbiwgYG5ldyBIRE5vZGVgIHdpbGwgdGhyb3dcblxuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBYIGNvb3JkaW5hdGUgaW4gdGhlIHB1YmxpYyBwb2ludCBjb3JyZXNwb25kcyB0byBhIHBvaW50IG9uIHRoZSBjdXJ2ZS5cbiAgICAvLyBJZiBub3QsIHRoZSBleHRlbmRlZCBwdWJsaWMga2V5IGlzIGludmFsaWQuXG4gICAgY3VydmUudmFsaWRhdGUoUSlcblxuICAgIGtleVBhaXIgPSBuZXcgRUNQYWlyKG51bGwsIFEsIHsgbmV0d29yazogbmV0d29yayB9KVxuICB9XG5cbiAgdmFyIGhkID0gbmV3IEhETm9kZShrZXlQYWlyLCBjaGFpbkNvZGUpXG4gIGhkLmRlcHRoID0gZGVwdGhcbiAgaGQuaW5kZXggPSBpbmRleFxuICBoZC5wYXJlbnRGaW5nZXJwcmludCA9IHBhcmVudEZpbmdlcnByaW50XG5cbiAgcmV0dXJuIGhkXG59XG5cbkhETm9kZS5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMua2V5UGFpci5nZXRBZGRyZXNzKClcbn1cblxuSEROb2RlLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYmNyeXB0by5oYXNoMTYwKHRoaXMua2V5UGFpci5nZXRQdWJsaWNLZXlCdWZmZXIoKSlcbn1cblxuSEROb2RlLnByb3RvdHlwZS5nZXRGaW5nZXJwcmludCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0SWRlbnRpZmllcigpLnNsaWNlKDAsIDQpXG59XG5cbkhETm9kZS5wcm90b3R5cGUuZ2V0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMua2V5UGFpci5nZXROZXR3b3JrKClcbn1cblxuSEROb2RlLnByb3RvdHlwZS5nZXRQdWJsaWNLZXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmtleVBhaXIuZ2V0UHVibGljS2V5QnVmZmVyKClcbn1cblxuSEROb2RlLnByb3RvdHlwZS5uZXV0ZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5ldXRlcmVkS2V5UGFpciA9IG5ldyBFQ1BhaXIobnVsbCwgdGhpcy5rZXlQYWlyLlEsIHtcbiAgICBuZXR3b3JrOiB0aGlzLmtleVBhaXIubmV0d29ya1xuICB9KVxuXG4gIHZhciBuZXV0ZXJlZCA9IG5ldyBIRE5vZGUobmV1dGVyZWRLZXlQYWlyLCB0aGlzLmNoYWluQ29kZSlcbiAgbmV1dGVyZWQuZGVwdGggPSB0aGlzLmRlcHRoXG4gIG5ldXRlcmVkLmluZGV4ID0gdGhpcy5pbmRleFxuICBuZXV0ZXJlZC5wYXJlbnRGaW5nZXJwcmludCA9IHRoaXMucGFyZW50RmluZ2VycHJpbnRcblxuICByZXR1cm4gbmV1dGVyZWRcbn1cblxuSEROb2RlLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKGhhc2gpIHtcbiAgcmV0dXJuIHRoaXMua2V5UGFpci5zaWduKGhhc2gpXG59XG5cbkhETm9kZS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKGhhc2gsIHNpZ25hdHVyZSkge1xuICByZXR1cm4gdGhpcy5rZXlQYWlyLnZlcmlmeShoYXNoLCBzaWduYXR1cmUpXG59XG5cbkhETm9kZS5wcm90b3R5cGUudG9CYXNlNTggPSBmdW5jdGlvbiAoX19pc1ByaXZhdGUpIHtcbiAgaWYgKF9faXNQcml2YXRlICE9PSB1bmRlZmluZWQpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIGFyZ3VtZW50IGluIDIuMC4wJylcblxuICAvLyBWZXJzaW9uXG4gIHZhciBuZXR3b3JrID0gdGhpcy5rZXlQYWlyLm5ldHdvcmtcbiAgdmFyIHZlcnNpb24gPSAoIXRoaXMuaXNOZXV0ZXJlZCgpKSA/IG5ldHdvcmsuYmlwMzIucHJpdmF0ZSA6IG5ldHdvcmsuYmlwMzIucHVibGljXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNzgpXG5cbiAgLy8gNCBieXRlczogdmVyc2lvbiBieXRlc1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2ZXJzaW9uLCAwKVxuXG4gIC8vIDEgYnl0ZTogZGVwdGg6IDB4MDAgZm9yIG1hc3RlciBub2RlcywgMHgwMSBmb3IgbGV2ZWwtMSBkZXNjZW5kYW50cywgLi4uLlxuICBidWZmZXIud3JpdGVVSW50OCh0aGlzLmRlcHRoLCA0KVxuXG4gIC8vIDQgYnl0ZXM6IHRoZSBmaW5nZXJwcmludCBvZiB0aGUgcGFyZW50J3Mga2V5ICgweDAwMDAwMDAwIGlmIG1hc3RlciBrZXkpXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHRoaXMucGFyZW50RmluZ2VycHJpbnQsIDUpXG5cbiAgLy8gNCBieXRlczogY2hpbGQgbnVtYmVyLiBUaGlzIGlzIHRoZSBudW1iZXIgaSBpbiB4aSA9IHhwYXIvaSwgd2l0aCB4aSB0aGUga2V5IGJlaW5nIHNlcmlhbGl6ZWQuXG4gIC8vIFRoaXMgaXMgZW5jb2RlZCBpbiBiaWcgZW5kaWFuLiAoMHgwMDAwMDAwMCBpZiBtYXN0ZXIga2V5KVxuICBidWZmZXIud3JpdGVVSW50MzJCRSh0aGlzLmluZGV4LCA5KVxuXG4gIC8vIDMyIGJ5dGVzOiB0aGUgY2hhaW4gY29kZVxuICB0aGlzLmNoYWluQ29kZS5jb3B5KGJ1ZmZlciwgMTMpXG5cbiAgLy8gMzMgYnl0ZXM6IHRoZSBwdWJsaWMga2V5IG9yIHByaXZhdGUga2V5IGRhdGFcbiAgaWYgKCF0aGlzLmlzTmV1dGVyZWQoKSkge1xuICAgIC8vIDB4MDAgKyBrIGZvciBwcml2YXRlIGtleXNcbiAgICBidWZmZXIud3JpdGVVSW50OCgwLCA0NSlcbiAgICB0aGlzLmtleVBhaXIuZC50b0J1ZmZlcigzMikuY29weShidWZmZXIsIDQ2KVxuXG4gIC8vIDMzIGJ5dGVzOiB0aGUgcHVibGljIGtleVxuICB9IGVsc2Uge1xuICAgIC8vIFg5LjYyIGVuY29kaW5nIGZvciBwdWJsaWMga2V5c1xuICAgIHRoaXMua2V5UGFpci5nZXRQdWJsaWNLZXlCdWZmZXIoKS5jb3B5KGJ1ZmZlciwgNDUpXG4gIH1cblxuICByZXR1cm4gYmFzZTU4Y2hlY2suZW5jb2RlKGJ1ZmZlcilcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzMi5tZWRpYXdpa2kjY2hpbGQta2V5LWRlcml2YXRpb24tY2tkLWZ1bmN0aW9uc1xuSEROb2RlLnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdHlwZWZvcmNlKHR5cGVzLlVJbnQzMiwgaW5kZXgpXG5cbiAgdmFyIGlzSGFyZGVuZWQgPSBpbmRleCA+PSBIRE5vZGUuSElHSEVTVF9CSVRcbiAgdmFyIGRhdGEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMzcpXG5cbiAgLy8gSGFyZGVuZWQgY2hpbGRcbiAgaWYgKGlzSGFyZGVuZWQpIHtcbiAgICBpZiAodGhpcy5pc05ldXRlcmVkKCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBkZXJpdmUgaGFyZGVuZWQgY2hpbGQga2V5JylcblxuICAgIC8vIGRhdGEgPSAweDAwIHx8IHNlcjI1NihrcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICBkYXRhWzBdID0gMHgwMFxuICAgIHRoaXMua2V5UGFpci5kLnRvQnVmZmVyKDMyKS5jb3B5KGRhdGEsIDEpXG4gICAgZGF0YS53cml0ZVVJbnQzMkJFKGluZGV4LCAzMylcblxuICAvLyBOb3JtYWwgY2hpbGRcbiAgfSBlbHNlIHtcbiAgICAvLyBkYXRhID0gc2VyUChwb2ludChrcGFyKSkgfHwgc2VyMzIoaW5kZXgpXG4gICAgLy8gICAgICA9IHNlclAoS3BhcikgfHwgc2VyMzIoaW5kZXgpXG4gICAgdGhpcy5rZXlQYWlyLmdldFB1YmxpY0tleUJ1ZmZlcigpLmNvcHkoZGF0YSwgMClcbiAgICBkYXRhLndyaXRlVUludDMyQkUoaW5kZXgsIDMzKVxuICB9XG5cbiAgdmFyIEkgPSBjcmVhdGVIbWFjKCdzaGE1MTInLCB0aGlzLmNoYWluQ29kZSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIHZhciBJTCA9IEkuc2xpY2UoMCwgMzIpXG4gIHZhciBJUiA9IEkuc2xpY2UoMzIpXG5cbiAgdmFyIHBJTCA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihJTClcblxuICAvLyBJbiBjYXNlIHBhcnNlMjU2KElMKSA+PSBuLCBwcm9jZWVkIHdpdGggdGhlIG5leHQgdmFsdWUgZm9yIGlcbiAgaWYgKHBJTC5jb21wYXJlVG8oY3VydmUubikgPj0gMCkge1xuICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEpXG4gIH1cblxuICAvLyBQcml2YXRlIHBhcmVudCBrZXkgLT4gcHJpdmF0ZSBjaGlsZCBrZXlcbiAgdmFyIGRlcml2ZWRLZXlQYWlyXG4gIGlmICghdGhpcy5pc05ldXRlcmVkKCkpIHtcbiAgICAvLyBraSA9IHBhcnNlMjU2KElMKSArIGtwYXIgKG1vZCBuKVxuICAgIHZhciBraSA9IHBJTC5hZGQodGhpcy5rZXlQYWlyLmQpLm1vZChjdXJ2ZS5uKVxuXG4gICAgLy8gSW4gY2FzZSBraSA9PSAwLCBwcm9jZWVkIHdpdGggdGhlIG5leHQgdmFsdWUgZm9yIGlcbiAgICBpZiAoa2kuc2lnbnVtKCkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEpXG4gICAgfVxuXG4gICAgZGVyaXZlZEtleVBhaXIgPSBuZXcgRUNQYWlyKGtpLCBudWxsLCB7XG4gICAgICBuZXR3b3JrOiB0aGlzLmtleVBhaXIubmV0d29ya1xuICAgIH0pXG5cbiAgLy8gUHVibGljIHBhcmVudCBrZXkgLT4gcHVibGljIGNoaWxkIGtleVxuICB9IGVsc2Uge1xuICAgIC8vIEtpID0gcG9pbnQocGFyc2UyNTYoSUwpKSArIEtwYXJcbiAgICAvLyAgICA9IEcqSUwgKyBLcGFyXG4gICAgdmFyIHBvaW50ID0gZmFzdGN1cnZlLnB1YmxpY0tleUNyZWF0ZShJTCwgZmFsc2UpXG4gICAgdmFyIEtpID0gcG9pbnQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBlY3VydmUuUG9pbnQuZGVjb2RlRnJvbShjdXJ2ZSwgcG9pbnQpLmFkZCh0aGlzLmtleVBhaXIuUSlcbiAgICAgIDogY3VydmUuRy5tdWx0aXBseShwSUwpLmFkZCh0aGlzLmtleVBhaXIuUSlcblxuICAgIC8vIEluIGNhc2UgS2kgaXMgdGhlIHBvaW50IGF0IGluZmluaXR5LCBwcm9jZWVkIHdpdGggdGhlIG5leHQgdmFsdWUgZm9yIGlcbiAgICBpZiAoY3VydmUuaXNJbmZpbml0eShLaSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEpXG4gICAgfVxuXG4gICAgZGVyaXZlZEtleVBhaXIgPSBuZXcgRUNQYWlyKG51bGwsIEtpLCB7XG4gICAgICBuZXR3b3JrOiB0aGlzLmtleVBhaXIubmV0d29ya1xuICAgIH0pXG4gIH1cblxuICB2YXIgaGQgPSBuZXcgSEROb2RlKGRlcml2ZWRLZXlQYWlyLCBJUilcbiAgaGQuZGVwdGggPSB0aGlzLmRlcHRoICsgMVxuICBoZC5pbmRleCA9IGluZGV4XG4gIGhkLnBhcmVudEZpbmdlcnByaW50ID0gdGhpcy5nZXRGaW5nZXJwcmludCgpLnJlYWRVSW50MzJCRSgwKVxuXG4gIHJldHVybiBoZFxufVxuXG5IRE5vZGUucHJvdG90eXBlLmRlcml2ZUhhcmRlbmVkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHR5cGVmb3JjZSh0eXBlcy5VSW50MzEsIGluZGV4KVxuXG4gIC8vIE9ubHkgZGVyaXZlcyBoYXJkZW5lZCBwcml2YXRlIGtleXMgYnkgZGVmYXVsdFxuICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyBIRE5vZGUuSElHSEVTVF9CSVQpXG59XG5cbi8vIFByaXZhdGUgPT09IG5vdCBuZXV0ZXJlZFxuLy8gUHVibGljID09PSBuZXV0ZXJlZFxuSEROb2RlLnByb3RvdHlwZS5pc05ldXRlcmVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISh0aGlzLmtleVBhaXIuZClcbn1cblxuSEROb2RlLnByb3RvdHlwZS5kZXJpdmVQYXRoID0gZnVuY3Rpb24gKHBhdGgsIGNhY2hlKSB7XG4gIHR5cGVmb3JjZSh0eXBlcy5CSVAzMlBhdGgsIHBhdGgpXG4gIHR5cGVmb3JjZSh0eXBlcy5tYXliZSh0eXBlcy5PYmplY3QpLCBjYWNoZSlcblxuICBjYWNoZSA9IGNhY2hlIHx8IHRoaXMuZGVyaXZhdGlvbkNhY2hlXG5cbiAgdmFyIHNwbGl0UGF0aCA9IHBhdGguc3BsaXQoJy8nKVxuICBpZiAoc3BsaXRQYXRoWzBdID09PSAnbScpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRGaW5nZXJwcmludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBtYXN0ZXIgbm9kZScpXG4gICAgfVxuXG4gICAgc3BsaXRQYXRoID0gc3BsaXRQYXRoLnNsaWNlKDEpXG4gIH1cblxuICByZXR1cm4gc3BsaXRQYXRoLnJlZHVjZShmdW5jdGlvbiAocHJldkhkLCBpbmRleFN0cikge1xuICAgIHZhciBpbmRleFxuICAgIHZhciBjYWNoZU9iamVjdCA9IGNhY2hlW2luZGV4U3RyXSB8fCB7fVxuICAgIGlmIChjYWNoZU9iamVjdC5ub2RlKSB7XG4gICAgICBjYWNoZSA9IGNhY2hlT2JqZWN0Lm5leHRcbiAgICAgIHJldHVybiBjYWNoZU9iamVjdC5ub2RlXG4gICAgfVxuICAgIGlmIChpbmRleFN0ci5zbGljZSgtMSkgPT09IFwiJ1wiKSB7XG4gICAgICBpbmRleCA9IHBhcnNlSW50KGluZGV4U3RyLnNsaWNlKDAsIC0xKSwgMTApXG4gICAgICBjYWNoZU9iamVjdC5ub2RlID0gcHJldkhkLmRlcml2ZUhhcmRlbmVkKGluZGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IHBhcnNlSW50KGluZGV4U3RyLCAxMClcbiAgICAgIGNhY2hlT2JqZWN0Lm5vZGUgPSBwcmV2SGQuZGVyaXZlKGluZGV4KVxuICAgIH1cblxuICAgIGNhY2hlW2luZGV4U3RyXSA9IGNhY2hlT2JqZWN0XG4gICAgY2FjaGVPYmplY3QubmV4dCA9IHt9XG4gICAgY2FjaGUgPSBjYWNoZU9iamVjdC5uZXh0XG4gICAgcmV0dXJuIGNhY2hlT2JqZWN0Lm5vZGVcbiAgfSwgdGhpcylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRUNQYWlyIG9iamVjdCBmcm9tIHRoaXMgSEROb2RlJ3MgRUNQYWlyLlxuICpcbiAqIFVzZXMgc2VjcDI1NmsxIGlmIGF2YWlsYWJsZSBmb3IgYWNjZWxlcmF0ZWQgY29tcHV0YXRpb24gb2YgdGhlIGNsb25lZCBwdWJsaWMga2V5LlxuICogQHJldHVybiB7RUNQYWlyfVxuICovXG5IRE5vZGUucHJvdG90eXBlLmNsb25lS2V5cGFpciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGsgPSB0aGlzLmtleVBhaXJcbiAgdmFyIHJlc3VsdCA9IG5ldyBFQ1BhaXIoay5kLCBrLmQgPyBudWxsIDogay5RLCB7XG4gICAgbmV0d29yazogay5uZXR3b3JrLFxuICAgIGNvbXByZXNzZWQ6IGsuY29tcHJlc3NlZFxuICB9KVxuICAvLyBDcmVhdGluZyBRIGZyb20gZCB0YWtlcyB+MjVtcywgc28gaWYgaXQncyBub3QgY3JlYXRlZCwgdXNlIG5hdGl2ZSBiaW5kaW5ncyB0byBwcmUtY29tcHV0ZVxuICAvLyBpZiBRIGlzIG5vdCBzZXQgaGVyZSwgaXQgd2lsbCBiZSBsYXppbHkgY29tcHV0ZWQgdmlhIHRoZSBzbG93IHBhdGhcbiAgaWYgKCFyZXN1bHQuX19RKSB7XG4gICAgdmFyIHBvaW50ID0gZmFzdGN1cnZlLnB1YmxpY0tleUNyZWF0ZShrLmQudG9CdWZmZXIoMzIpLCBmYWxzZSlcbiAgICBpZiAocG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0Ll9fUSA9IGVjdXJ2ZS5Qb2ludC5kZWNvZGVGcm9tKGN1cnZlLCBwb2ludClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhETm9kZVxuIl19